/* <orly/variant.h>

   The goal here is to replace type, var, atom, and sabot all in one foul swoop with a single coherent collection
   of classes, most of which are generated by macro expansion. All of these have a lot of commonalities to eachother
   and

   Copyright 2010-2014 OrlyAtomics, Inc.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License. */


namespace Orly {
  /* Type is an enum of the top layer type + a variant structure which holds any necessary additional state.

     For shallow type, we point to this enum + variant structure. The whole objects are interned (Which effectively)
     interns the variant type

     The variant structure is interned which gives us
     the pointer comparison
  */

  /* Types:

  Open Questions:
    Unwrapping decending, opt, free to compare their inner types most of the time by default?
      - Treating them as modifiers / addons?


  void
  tombstone - Used in DB for deleted things. When gets into the language, acts as void.

  [u]int{1..n, inf}
    alias: int1 -> bool
  float{32, 64, 128}
  char: integer type (Size depends on encoding), paired with encoding for how to decode it
  array<type>: Arrays of things

  blob: A wrapped uintn. Ideally has a mime type attached. Not null terminated
  string: Alias for array<char>. Yanks the per-character encoding out and attaches it to the container. Guarantees the string is null-terminated

  desc<type>: Modifier type, that we should sort in reverse
    free<type>: Marks that any type works / solve for this type.
  set<type>

  //TODO: Should we allow a non-homogenous array, set, and map? Practically speaking we can cope with it?
  // Actually, that's the same as union types
  map<type, type>: Map from type a to type b.

  record: Aka object / struct / etc.
  tuple: Vector of non-identical types
  union: How you deal with something beign one of n types

  wrapper / convenience typs:
  time_diff (ratio), time_pnt (ratio):
    These have some special added semantics and helper functions for construction / destruction
    Math between these is a little special, but not too crazy
  uuid: Effectively a wrapped uint128 with special printing, generation rules
  opt: Union type of void|type. Propogates through the type system in a predictable way (And can behave under basic addition, subtraction, etc.)

  ratio: Collection of two int or uint types. denominator is fixed / compile time.
         Used for money types / fixed precision
         Used for various units (Namely date-time math)
         This is a special struct

  opt<type>: Wrapper around a 2-element struct {bool data, value}
       If the bool is true, the value is set / valid. Otherwise not
       Bool being false in any operation leads to the result of that operation having the bool be false.
  */

  // Flat Type object (value / deep comparison mandatory). Used for storage, transport, IPC.
  class TType;

  // Shallow / pointer comparable types
  // Used inside the compiler because it does a lot of type comparisons, this makes them cheap
  class TTypeShallow;

  // Flat value holder. Doesn't try to do any sort of reference counting or the like.
  class TVariant;

  // Flyweight value type. Stores / retrieves data from an Arena which interns it / owns the storage.
  // The storage determines if this is a value type or not / copies around.
  class TVariantFlyweight;

  TType GetType(TVariant v);
}